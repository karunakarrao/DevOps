Docker: Overview
-----------------------------------------------------
Docker is a Containerization platform. Containerization will encapsulating or packaging up softwares and all its dependencies, so that it can run uniformly and consistently on any infrastructure. 

Docker Architecture:Overview
-----------------------------------------------------
The docker engine consists of 3 componenets.
	1). Docker Daemon
	2). Docker client
	3). REST API
Docker Daemon: The daemon (dockerd) is a process that keeps running in the background and waits for commands from the client. The daemon is capable of managing various Docker objects.

Docker Client: The client  (docker) is a command-line interface program mostly responsible for transporting commands issued by users.

REST API: The REST API acts as a bridge between the daemon and the client. Any command issued using the client passes through the API to finally reach the daemon.

"Docker uses a client-server architecture. The Docker client talks to the Docker daemon, which does the heavy lifting of building, running, and distributing your Docker containers". You as a user will usually execute commands using the client component. The client then use the REST API to reach out to the long running daemon and get your work done.

Docker: Install
-----------------------------------------------------
Docker installation on CentOS
		 
	 $ sudo yum install -y yum-utils	--> install yum-utils package
	 $ sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo	--> add repository 

	 $ sudo yum install docker-ce docker-ce-cli containerd.io	-->install 3 components. 

	 $ sudo systemctl start docker	--> start docker as service.

Docker: commands
-----------------------------------------------------

		$ docker --version	--> docker version
		$ docker-compose --version	--> 
		
		$ docker run hello-world	--> running simple docker image hello-world
		$ docker ps -a --> to check the hello-world containers
		
What is a Container?
-----------------------------------------------------
A container is an abstraction at the application layer that packages code and dependencies together. Instead of virtualizing the entire physical machine, containers virtualize the host operating system only.

What is a Docker Image?
-----------------------------------------------------
Images are multi-layered self-contained files that act as the template for creating containers. They are like a frozen, read-only copy of a container. Images can be exchanged through registries.

What is a Docker Registry?
-----------------------------------------------------
An image registry is a centralized place where you can upload your images and can also download images created by others. Docker Hub is the default public registry for Docker. 
	link: https://hub.docker.com/

Full Picture how the Docker works ?
-----------------------------------------------------
1). You execute "docker run hello-world" command where hello-world is the name of an image.

2). Docker client reaches out to the daemon, tells it to get the hello-world image and run a container from that.

3). Docker daemon looks for the image within your local repository and realizes that it's not there, resulting in the Unable to find image 'hello-world:latest' locally that's printed on your terminal.

4). The daemon then reaches out to the default public registry which is Docker Hub and pulls in the latest copy of the hello-world image, indicated by the latest: Pulling from library/hello-world line in your terminal.

5). Docker daemon then creates a new container from the freshly pulled image.

6). Finally Docker daemon runs the container created using the hello-world image outputting the wall of text on your terminal.

How to Publish a Port to access the application ?
-----------------------------------------------------
Containers are isolated environments. Your host system doesn't know anything about what's going on inside a container. Hence, applications running inside a container remain inaccessible from the outside. To allow access from outside of a container, you must publish the appropriate port inside the container to a port on your local network. 

	$ docker run <image-fullname> --publish <host port>:<container port>	--> common syntax for the --publish or -p option is as follows

When you wrote --publish 8080:80, any request sent to port 8080 of your host system will be forwarded to port 80 inside the container. Now to access the application on your browser, visit http://127.0.0.1:8080

	$ docker run nginx  --publish 8080:80 --name=my-nginx
	

Docker commands: container handling
------------------------------------------------------

$ docker --version	--> version checking
$ docker-compose --version	--> 

Note: docker image should be specified at the end of the command. other wise docker image will not get created. show options are not avialbe.
	Usage:  $ docker run [OPTIONS] IMAGE [COMMAND] [ARG...]

$ docker run -p 8081:80 nginx	--> deploying nginx image
(or)
$ docker container run -p 8082:80 nginx	

$ docker create --name=my-redis	redis	--> to create a redis container with name my-redis


$ docker run --name=my-nginx -p 8081:80 --rm nginx	--> to name container as "my-nginx" and --rm to remove the contianer once its stopped. 
$ docker run -d -p 8082:80 nginx	--> to detach container, it will run in background. to attach again use --attach
$ docker attach <container-name/container-ID>	--> to attach the detached container

$ docker start <container-name/container-ID>	--> start the stopped container
$ docker stop <container-name/container-ID>	--> shuts down a container gracefully 
$ docker restart <container-name/container-ID>	--> restart the container
$ docker kill <container-name/container-ID> 	--> to kill the process

$ docker ps	--> to list the docker process
$ docker ps -a 	--> to list all the process which are stopped also

$ docker rm <container-name/container-ID>	--> to remove a stopped/Exited container

$ docker exec -it <container-name/container-ID> <command> 	--> -i interactive and -t terminal
$ docker exec -it my-nginx /bin/bash	--> connecting to running docker conatainer (my-nginx is container name)
$ docker exec my-nginx uname -a --> to exicute a command to check os details cmd: uname -a



docker: volumes
---------------------------------------------------------
containers are short lived object they are destroyed once the container work is over, but the data it collected also removed once the container is destroied. so to make the data persistant or to use for time to time we need to map the container path to localhost path so that the data is save persistantly.

this is where the --volumes come in to picture.

$ docker run 


Docker : Image handling
------------------------------------------------------

Dockerfiles:
---------------------------------------------------------------
to customize the image, we need to lear vision of what you want from the image. 
make a custom NGINX image, you must have a clear picture of what the final state of the image will be.
	1. The image should have NGINX pre-installed which can be done using a package manager or can be built from source.
	2. The image should start NGINX automatically upon running.

step-1: Now, create a new file named Dockerfile in an empty directory custom-nginx. A Dockerfile is a collection of instructions that, once processed by the daemon, results in an image. Content for the Dockerfile is as follow
-------------------------------------------------------------
FROM ubuntu:latest

EXPOSE 80

RUN apt-get update && \
    apt-get install nginx -y && \
    apt-get clean && rm -rf /var/lib/apt/lists/*

CMD ["nginx", "-g", "daemon off;"]
-------------------------------------------------------------

Images are multi-layered files and in this file, each line (known as instructions) that you've written creates 

FROM: Every valid Dockerfile starts with a FROM instruction. This instruction sets the base image for your resultant image.
EXPOSE: The EXPOSE instruction is used to indicate the port that needs to be published. 
RUN: The RUN instruction in a Dockerfile executes a command inside the container shell. 
CMD: Finally the CMD instruction sets the default command for your image.

to build the image need to use the command build from custom-nginx directory

$ docker build . --> to build the docker image without tags
$ docker image build --tag custom-nginx:packaged . --> to tag the docker image. REPOSITORY-name is custom-nginx  and  TAG is packaged

$ docker images --> to lis the images.
