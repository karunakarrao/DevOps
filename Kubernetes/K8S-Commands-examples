$ kubectl version --> to check the kubernetes version

$ kubectl explain <Object-name> --> Documentation for resource object (Pod, Replicaset, Deployment, service, etc.)
examples:
    $ kubectl explain pod --> Documentation for POD. to check apiVersion of k8s object.
    $ kubectl explain replicaset/rs --> Documentation for Replicaset
    $ kubectl explain replicationcontroller/rc --> Doc. for RC
    $ kubectl explain deployment/deploy --> doc for deployment
    $ kubectl explain service/svc --> doc for service

Kubernetes objects (Pod,Replicasets,Deployments,service,etc) are created in two types.
    1. imperative --> objects created using command line are called imperative.
    2. declarative --> objects created using yml/programing are called declarative.

POD:
====
Syntax: Imperative way
$ kubectl run {...} --> only used to create pod object 
$ kubectl run <Pod-Name> --image=<Pod-image-name>  --> to run a pod 
Examples:
$ kubectl run nginx --image=nginx --> creating a nginx pod
$ kubectl run redis --image=redis --> creating a redis pod
    
Syntax: Declarative way
$ kubectl create -f pod-definition.yaml 

pod-definition.yaml--> POD-definition file in YAML format :
-----------------------------------------------------------
apiVersion: v1
kind: Pod
metadata: 
    name: nginx-pod
    labels:
        app: nginx
spec: 
    containers:
    - name: nignx
      image: nginx
-------------------------------------------------------------

$ kubectl get pods --> to list pods running on default namespace
$ kubectl get pods  -w --> to watch the pod status on fly
$ kubectl get all --> to list all objects(Pod, Replicasets, Deploylments, services, etc.) running in default namespace
$ kubectl get pods -n prod1-namespace  -> to list the pods running on the namespace prod1-namespace
(or)
$ kubectl get pods --namespace=prod1-namespace
$ kubectl get all --namespace=kube-system --> to list "kube-system" namespace objects, kubernetes object namespace

examples:
$ kubectl get nodes
$ kubectl get pods
$ kubectl get replicationcontrollers
$ kubectl get replicasets
$ kubectl get deployments
$ kubectl get services
$ kubectl get namespaces
$ kubectl get daemonsets

$ kubectl describe pod <pod-name> --> to see the details of pod and properties
example:
$ kubectl describe pod my-pod1
$ kubectl describe pods
$ kubectl describe replicaset my-replicaset1
$ kubectl describe replicasets
$ kubectl describe deployment my-deployment1
$ kubectl describe deployments
$ kubectl describe daemonsets --namespace=kube-system
$ kubectl describe -n kube-system daemonsets    --> -n is namespace 

ReplicationController:
======================

replicationcontroller-definition.yaml --> with help of this YAML file we replicate n times. same pod used in pod-definition.yaml :
----------------------------------------------------------------------------------------------------------------------------------
apiVersion: v1
kind: ReplicationController
metadata:
    name: my-rc
    labels:
        app: my-rc-nginx
spec:
    replicas: 3
    template:
        metadata: 
            name: nginx-pod
            labels:
                app: nginx
        spec: 
            containers:
            - name: nignx
              image: nginx
---------------------------------------------------------------------------------------------------------------------------------
Create: ReplicationController
=============================
$ kubectl create -f replicationcontroller-definition.yaml
$ kubectl get replicaitoncontroller
(or)
$ kubectl get rc
$ kubectl delete rc my-rc1
$ kubectl describe rc my-rc1
$ kubectl edit rc my-rc1
$ kubectl replace -f replicationcontroller-definiton.v2.yaml

Replicaset:
===========
ReplicationController and ReplicaSet are used for similer functionality. ReplicationController is older version, ReplicaSet is the newer version.

replicaset-definition.yaml
-------------------------------------------------------------------------------------
apiVersion: apps/v1
kind: ReplicaSet
metadata:
    name: my-rs
    labels:
        app: my-rs-nginx
spec:
    template:
        metadata: 
            name: nginx-pod
            labels:
                app: nginx
        spec: 
            containers:
            - name: nignx
              image: nginx
    selector:
        matchLabels:
            app: nginx    
    replicas: 5
-----------------------------------------------------------------------------------
Create: ReplicaSet
==================
$ kubectl create -f replicaset-definition.v1.yaml --dry-run=client --> to run the YAML file with out applying the changes
$ kubectl create -f replicaset-definition.v1.yaml   --> create replicaset
$ kubectl get replicaset    --> list replicasets
(or)
$ kubectl get rs    --> list replicasets 
$ kubectl describe replicaset my-rs --> describe replicaset properties
$ kubectl replace -f replicaset-definition.v2.yaml  --> replace the replicaset with latest version
$ kubectl scale replicaset my-rs --replicas=10  --> scale up number of replicas 
(or)
$ kubectl scale -f replicaset-definition.yaml --replicas=10 --> scale up number of replicas using replicaset definition file
$ kubectl scale -f replicaset-definition.yaml --replicas=2 --> scale down number of replicas
$ kubectl edit replicaset my-rs   --> edit the replicaset properties using the 
$ kubectl explain replicaset|grep -i version
$ kubectl delete replicaset my-rs --> to delete replicaset my-rs

Deployment:
===========
$ kubectl create deployment my-deploy --image=nginx --> creating a deployment with single POD
$ kubectl create deployment my-deploy --image=nginx --replicas=6 --> create a deployment with 6 pod in cluster
$ kubectl create deployment my-deploy --image=nginx --replicas=6 --dry-run=client -o yaml > my-deploy.yaml --> it will create a yaml of that deployment. 
$ kubectl get deployment my-deploy -o wide --> deployment details

deployment-definition.yaml --> this deployment YAML file creates PODs, Replicasets, Deployment objects
-------------------------------------------------------------------------------------------------------
apiVersion: apps/v1
kind: Deployment
metadata: 
    name: my-deploy
spec:
    replicas: 5
    selector:
        matchLabels:
            app: nginx
    template:
        metadata:
            name: nginx-pod
            labels:
                app: nginx
        spec:
            containers:
            - name: nginx
              image: nginx
------------------------------------------------------------------------------------------------------
Create: Deployment:
===================
$ kubectl create -f deployment-definition.yaml --dry-run=client --> to trial run the YAML file, if will not apply any changes
$ kubectl create -f deployment-definition.yaml --> to exicute the YAML file.
(or)
$ kubectl apply -f deployment-definition.yaml --> 
$ kubectl get deployment    --> to check deployments available
(or)
$ kubectl get deploy --> to check deployments available
$ kubectl get deployment my-deply --> to check one deployment my-deploy
$ kubectl get deployment --namespace=dev --> to check the deploymets running on namespace "dev"
$ kubectl describe deployment my-deploy 
$ kubectl delete deployment my-deploy
$ kubectl edit deployment my-deploy --> update the version by editing the running deployment.

deployment rollout is done in two ways 
    1. rollingupdate (Default) --> it will bringdown one by one depends on RollingUpdateStrategy defined. 
    2. recreate --> will bringdown all pods at a time, and brinup all 

Update: Deployment
==================
$ kubectl apply -f deployment-definition.v2.yaml --> to update the latest version of application.
$ kubectl replace -f deployment-definition.v2.yaml --> updating the app version(nginx to nginx:1.16.2) using the YAML and replace with running deployment.
$ kubectl replace --force -f deployment-definition.v2.yaml --> this will bring down the existing deployment forcefully and creates the new one.
$ kubectl set image deployment my-deploy nginx=nginx:1.16.1 --> to set the latest nginx image on the running deployment
$ kubectl rollout history deployment my-deploy --> history of the number of deployments
$ kubectl rollout status deployment my-deploy --> deployment status can be checked. 
$ kubectl rollout undo deployment my-deploy --> if update is failed for some reason, then rollout the new-version deployment to the old-verison deployment 
$ kubectl scale deployment my-deploy --replicas=10 --> to scale up the deployment
$ kubectl scale deployment my-deploy --replicas=3 --> to scale down the deployment

Note: remember every time new-verison changed, respective "replicaset" is brought down parallel a new "replicaset" is created with new-verison, the old replicasets
will avaiable but not pods will be avaiable in running state. when you do the undo operation thet old replicaset is recreated and new one will go down.

Service:
========
Service is a k8s object, which exposes the sevice to the outside network. this can be done in two ways. by using the command line parameter "expose" we can expose
the service to the outside network.

--> 

ClusterIP: Exposes the Service on a cluster-internal IP. Service only reachable from within the cluster. This is the default ServiceType.
$ kubectl expose deployment my-deploy --port=80 --> this expose the deployment as a clusterIP. to access URL use clusterIP.
example:
    $ kubectl get service -o wide
    NAME         TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)   AGE     SELECTOR
    my-deploy    ClusterIP   10.101.51.194   <none>        80/TCP    6m56s   app=nginx
    
--> to access the URL use clusterIP ip address 
    $  curl http://10.101.51.194

NodePort: Exposes the Service on each Node's IP at a static port (the NodePort). NodePort ranges from port 30000 to 32767.
$ kubectl expose deployment my-deploy --type=NodePort --port=80 --> expose it as NodePort, to access URL use nodeport with ip.
example: 
    $  kubectl get service
    NAME         TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)        AGE
    my-deploy    NodePort    10.104.86.214   <none>        80:31358/TCP   3m10s  
    
--> to access the URL use Node ip address and the NodePort
    $ curl http://localhost:31358
Note: remember the application listen port, should be same as --port other wise we can't access the application.

LoadBalancer: Exposes the Service externally using a cloud provider's load balancer. NodePort and ClusterIP Services, to which the external load balancer routes, 
are automatically created. this can only be achived with cloud providers like (Aws, Azure, GCP). 

?????????? pending ????????

service-definition.yaml
---------------------------------------------------------------------------------
apiVersion: v1
kind: Service
metadata:
    name: my-svc
spec:
    type: NodePort       # we can use this NodePort/LoadBalancer/ClusterIP
    ports:
    - port: 80           # nginx webserver listens on port: 80 (*), this is Service port
      targetPort: 80    # targetPort is a nginx POD port
      nodePort: 30008   # This port is Node port or external access port
    selector:
        app: nginx
----------------------------------------------------------------------------

service-clusterip-def.yaml
-----------------------------------------------------------------------------
apiVersion: v1
kind: service
metadata:
    name: my-svc-cluster
spec:
    type: ClusterIP  # if type is not specified, by default it uses "CluserIP"
    ports:
    - port: 80       # this is mandate field, its a service port
      targetPort: 80 # this is not mandate field, if not specified it will allocate same as port
    selector:
        app: nginx
-----------------------------------------------------------------------------

$ kubectl create -f sevice-definition.yaml --> to create the sevice
$ kubectl get services  --> to check the services
$ kubectl get services -o wide --> to see more details 
$ kubectl delete serivce my-svc --> to delete 
$ kubectl edit service my-svc --> to edit the service properties

NameSpace:
===========
In Kubernetes, namespaces provides a mechanism for isolating groups of resources(pods, replicasets, deployments, services, etc..) within a single cluster. 
Names of resources need to be unique within a namespace, but not across mutiple namespaces. In simple terms namespace is a isolated area for a team. 

$ kubectl get namespace --> to list the namespaces avaiable

Kubernetes starts with four initial namespaces:
    1. default: The default namespace for objects with no other namespace
    2. kube-system: The namespace for objects created by the Kubernetes system
    3. kube-public: This namespace is created automatically and is readable by all users 
    4. kube-node-lease: This namespace holds Lease objects associated with each node. it allow the "kubelet" to send heartbeats so that master node can detect node failure.
    
$ kubectl run nginx --image=nginx --namespace=prod1 --> creating a nginx pod in prod1 namespace
$ kubectl get pods --namespace=prod1 --> to list pods from namespace prod1
$ kubectl config set-context --current --namespace=prod1 --> to switch from "default" to "prod1" namespace
$ kubectl config view   --> to see configuration set currently on 
$ kubectl config view | grep namespace  --> to check the namespace currenlty we are working on
$ kubectl config get-contexts --> to get th context details with namespace

When you create a Service, it creates a corresponding DNS entry. This entry is of the form <service-name>.<namespace-name>.svc.cluster.local, which means that if a container 
only uses <service-name>, it will resolve to the service which is local to a namespace. This is useful for using the same configuration across multiple namespaces such as 
Development, Staging and Production. If you want to reach across namespaces, you need to use the fully qualified domain name (FQDN).



$ kubectl create namespace prod1 --> this will create  namespace prod1
(or)
prod1-namespace-def.yaml --> yaml file to create namespace prod1
-----------------------------------
apiVersion: v1
kind: Namespace
metadata:
    name: prod1
----------------------------------
nginx-prod1-definition.yaml --> this will create nginx pod in namespace prod1
-----------------------------------------------------------------------------------
apiVersion: v1
kind: Deployment
metadata:
    name: nginx-prod1
    namespace: prod1
spec:
    replicas: 4
    selector:
        matchLabels: nginx
    template:
        metadata:
            name: nginx
        spec:
            containers:
            - name: nginx
              image: nginx
 -------------------------------------------------------------------------

$ kubectl create -f prod1-namespace-def.yaml --> this yaml file create namespace prod1
$ kubectl create -f nginx-prod1-definition.yaml --> this will create nginx prod on namespace prod1
$ kubectl get pods --namespace=prod1 --> to list the prods
$ kubectl delelte namespace prod1 --> to delete the prod1 namespace
$ kubectl config get-context --> to check the namespace 
$ kubectl get namespace --show-labels --> to show labels of all namespaces

Namespace: ResourceQuota
=========================

?????????? Pending ???????????

before creating resource quota for namespace, we need to create namespace 
$ kubectl create namespace prod2

prod2-ns-resourcequota-def.yaml
-----------------------------------------------------------------------------
apiVersion: v1
kind: ResourceQuota
metadata:
  name: my-ns-rquota
  namespace: prod2
spec:
  hard:
    requests.cpu: "1"
    requests.memory: 1Gi
    limits.cpu: "2"
    limits.memory: 2Gi
    requests.nvidia.com/gpu: 4
-------------------------------------------------------------------------------
    
Manual scheduling:
==================
--> the scheduler is responsible to distribute the work among all the nodes equally, if a new node is created, it will allocate work to it. 
--> if you don't want a scheduler to chose where to create pod on the cluster nodes, specifing the parameter "nodeName", it will create pod on the defined Node name.
--> every pod has a field called "nodeName" which is by default not set, the scheduler goes to all PODs and looks for this property, if not avaialbe the scheduler will run 
an algoritham and assign a node to this pod. 
--> if scheduler is down, we can't start the pod it will go to pending state, to avoid this we can use NodeName parameter 
--> specifying the nodeName property only work during the pod creation, to change the pod nodeName during runtime we need to use Binding methord to change nodeName.

pod-definition.yaml --> this YAML file only work during the pod creation. we can't change node name during runtime with this yaml file.
-----------------------------------------------------------------------------------
apiVersion: v1
kind: Pod
metadata: 
    name: nginx-pod
    labels:
        app: nginx
spec:
    nodeName: controlplane # check the list on nodes avaiable and specify the name of the node
    containers:
    - name: nginx
      image: nginx
      ports:
        - containerPort: 8080
------------------------------------------------------------------------------------     

pod-bind-runtime.yaml --> this file will change the pod nodeName during runtime. but below file need to convert into JSON format. pass it as a command line option.
-------------------------------------------------------------------------------------
apiVersion: v1
kind: Binding
metadata: 
    name: nginx-pod
target:
    apiVersion: v1
    kind: Node
    name: node01
------------------------------------------------------------------------------------

Labels & Selectors:
===================
Labels and selectors are the properties attached to each k8s objects(Pods, deployments, services, etc..). they use to group kubernetes objects/resources to gether. 
